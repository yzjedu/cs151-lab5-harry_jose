# Reflection Document

* Drive Full Name  : Jose Carrillo 
* Partner Full Name: Harry
* Student ID: 1867377

Objective:
The goal of this lab was to learn how to break down a complex programming task using step by step processes, including the creation of a detailed flowchart to visually organize the steps. Specifically, the task required us to program an ATM system where users can deposit, withdraw, check their balance, or exit. The challenge was also to ensure that user inputs are validated, meaning that the program should handle incorrect inputs gracefully by using loops to re-prompt the user if necessary.

Procedure:
To approach the task, we started by visualizing how a real-life ATM functions. The user should be able to deposit money, withdraw funds, check their current balance, or exit the system entirely. Each operation needed to be clearly defined and accounted for in the flowchart and the algorithm. We used 'D' for deposits, 'W' for withdrawals, 'V' to view the balance, and 'E' for exit. If an invalid input was provided, a loop would re-prompt the user for a valid input. One key technique that helped was the .lower() function, which minimized errors from upper vs. lowercase input issues, ensuring that the program accepted valid commands regardless of letter case.

Key Concepts Explored:
The key concepts explored during this lab were loops and user input validation. The flow of the program was dictated by what the user inputted, and each possible input ('D', 'W', 'V', or 'E') took the user down a different path, which the flowchart illustrated well. Another important concept was the need for efficient handling of errors. By re-prompting users for valid input and keeping operations clear, we ensured that the program functioned without getting stuck or crashing due to invalid entries.

Results:
The results matched what we expected after debugging and refining the code, although the task was more complex than initially anticipated. Initially, writing the algorithm seemed straightforward, but as we incorporated various user inputs and ensured that each step functioned correctly, it became more involved. For example, when testing the program, we used both upper and lowercase inputs, as well as attempted withdrawals that exceeded the balance. The program handled these cases as expected, prompting the user for corrections when needed.

Reflection:
One of the biggest challenges was creating and committing the flowchart through GitHub. The flowchart diagram seemed very confusing and difficult to format in a digital environment. I found that drawing the flowchart by hand on paper was much easier for me because I’m more comfortable with physical drawings where I can easily erase and make changes as needed. Despite this, I still managed to upload a scanned version of my handwritten flowchart through Moodle, which was a good workaround for me.

The first three rules of programming were followed to a certain extent. Even after we thought the algorithm was complete, we realized further refinements were needed. Ultimately, we simplified the code to make it more efficient, particularly by using loops to handle invalid inputs and re-prompting users.

This lab was definitely challenging, but I learned a great deal about programming with loops and how important flowcharts are for visualizing and organizing complex tasks. As the labs get harder, I’ve noticed that breaking tasks down into smaller steps is essential. In the end, I did feel that I learned what I was supposed to, and the experience with loops was particularly valuable. Working with my partner was also a good learning experience; although the initial algorithm he suggested didn’t fully work, we collaborated effectively and built on that foundation to complete the task.


